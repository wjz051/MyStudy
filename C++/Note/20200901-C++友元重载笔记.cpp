一：友元
友元声明以关键字 friend 开始，它只能出现在类定义中。因为友元不是类授权的成员，所以它不受其所在类的声明区域 public private 和 protected 的影响。
 友元关系不能被继承。
 友元关系是单向的，不具有交换性。若类 B 是类 A 的友元，类 A 不一定是类 B的友元，要看在类中是否有相应的声明。
 友元关系不具有传递性。若类 B 是类 A 的友元，类 C 是 B 的友元，类 C 不一定是类 A 的友元，同样要看类中是否有相应的声明。


二：运算符重载
重载规则
7.2.1. 可被重载的操作符
+ - * / % ^ & | ~ ! , = < > >= <= ++ -- << >> == != && || += -= /= %= ^= &= |= *= <<= >>= [] () -> ->* new new[] delete delete[]
7.2.2. 不能新增运算符
只能对已有的 C++运算符进行重载。 例如， 有人觉得 BASIC 中用"* *"作为幂运算符很方便， 也想在 C++中将"* *"定义为幂运算符， 用"3* *5"表示 35， 这是不行的。
7.2.3. 不能改变操作数的个数
关系运算符">"和"<"等是双目运算符， 重载后仍为双目运算符， 需要两个参数。 运算符"+"， "-"， "*"， "&"等既可以作为单目运算符， 也可以作为双目运算符， 可以分别将它们重载为单目运算符或双目运算符。
7.2.4. 不改变语义
应当使重载运算符的功能类似于该运算符作用于标准类型数据时候时所实现的功能。
例如， 我们会去重载"+"以实现对象的相加， 而不会去重载"+"以实现对象相减的功能，因为这样不符合我们对"+"原来的认知。
7.2.5. 至少有一个操作数是自定义类
重载的运算符必须和用户定义的自定义类型的对象一起使用， 其参数至少应有一个 是类对象(或类对象的引用)。
也就是说， 参数不能全部是 C++的标准类型， 以防止用户修改用于标准类型数据成员的运算符的性质， 如下面这样是不对的：
复制代码 代码如下：
int operator + (int a,int b)
{
    return(a-b);
} 
原来运算符+的作用是对两个数相加， 现在企图通过重载使它的作用改为两个数相减。如果允许这样重载的话， 如果有表达式 4+3， 它的结果是 7 还是 1 呢？ 显然， 这是绝对要禁止的。
7.2.6. 其它
 不能改变运算符的优先级
例如"*"和"/"优先级高于"+"和"-"， 不论怎样进行重载， 各运算符之间的优先级不会改变。 有时在程序中希望改变某运算符的优先级， 也只能使用加括号的方法强制改变重载运算符的运算顺序。
 重载不能改变运算符的结合性。
如， 复制运算符"="是右结合性(自右至左)， 重载后仍为右结合性。
 重载运算符的函数不能有默认的参数
否则就改变了运算符参数的个数， 否则， 就会跟 7.2.3 相矛盾。
 某此运算定律未必支持
比如， 加法交换律， 见 7.5.4.2

运算符重载小结
7.5.1. 重载格式
操作符 表达式 成员函数表示 友元函数a.表示
前缀单目操作符@ @a a.operator@() operator@(a)           ++a a.operator++() operator++(a)
后缀单目操作符@ a@ a.operator@(0) operator@(a,0)
双目操作符@ a@b a.operator@(b) operator@(a,b)
赋值操作符= a=b a.operator=(b)
下标操作符[] a[b] a.operator=[](b)
类成员访问操作符-> a-> a.operator->()
7.5.2. 不可重载运算符
. 成员访问运算符  (*a). a.operator*()
.* 成员指针访问运算符
:: 域运算符
sizeof 长度运算符
?: 条件运算符
7.5.3. 只能重载为成员的运算符
= 赋值运算符
[] 下标运算符
() 函数运算符
-> 间接成员访问
->* 间接取值访问
常规建议
算符            建议使用
所有的一元运算符 成员
+= -= /= *= ^= &= != %= >>= <<= 成员(赋值类)
其它二元运算符  非成员

 一元运算符重载

 二元运算符重载
